#!/usr/bin/env bash
set -euo pipefail
set -o errtrace
trap 'mc_log "[EXPLORER][DEBUG] Error at line $LINENO exit $?"' ERR

# Reuse common helpers (mc_log) from base image.
if [[ -f /usr/local/bin/mc-common.sh ]]; then
	# shellcheck disable=SC1091
	source /usr/local/bin/mc-common.sh
else
	mc_log() { echo "$@" >&2; }
fi

# ==========================
# Environment Configuration
# ==========================
: "${CHAIN_NAME:=procuchain}"
: "${MASTER_HOST:=masternode}"
# Use runtime overrides from compose; defaults align with masternode service
: "${MASTER_PORT:=7447}"
: "${RPC_PORT:=8000}"
: "${RETRIES:=60}"
: "${SLEEP_SECONDS:=2}"
: "${EXPLORER_PORT:=2750}"
: "${EXPLORER_BIND:=0.0.0.0}"
: "${GENERATE_EXPLORER_CONF:=1}"   # Set to 0 to use pre-baked explorer.conf
: "${START_FLAGS:=-shrinkdebugfilesize}" # Additional multichaind flags (do not include -daemon)
: "${COMMIT_BYTES:=100000}"          # Initial indexing batch size
: "${EXPLORE_FLAGS:=}"               # Extra flags for Mce.abe (e.g. --reverse)
: "${FAST_START:=1}"                 # If 1 skip pre-index --no-serve pass

mc_log "[EXPLORER][DEBUG] FAST_START=${FAST_START} MASTER_PORT=${MASTER_PORT} RPC_PORT=${RPC_PORT}"

mc_log "[EXPLORER] Launching explorer for chain '${CHAIN_NAME}' (port ${EXPLORER_PORT})"

# Ensure we operate from a writable home directory so relative paths (if any) land here.
cd /home/multichain || mc_log "[EXPLORER][WARN] Failed to cd to /home/multichain"

# Normalize HOME (upstream image sets this, but be defensive)
HOME_DIR="${HOME:-/home/multichain}"
CHAIN_DIR="${HOME_DIR}/.multichain/${CHAIN_NAME}"

# --------------------------
# Wait for master reachability (mirrors logic in connect-node.sh)
# --------------------------
resolve_master() { getent hosts "$MASTER_HOST" | awk '{print $1}' | head -n1; }
attempt=0
ip=""
while [[ $attempt -lt $RETRIES ]]; do
	if ip=$(resolve_master) && [[ -n $ip ]]; then
		if (echo >/dev/tcp/$ip/$MASTER_PORT) >/dev/null 2>&1; then
			mc_log "[EXPLORER] Master reachable at $ip:$MASTER_PORT"
			break
		fi
	fi
	mc_log "[EXPLORER] Waiting for master ($((attempt+1))/$RETRIES)"
	attempt=$((attempt+1))
	sleep "$SLEEP_SECONDS"
done
[[ -z "$ip" ]] && { mc_log "[EXPLORER][ERROR] Master not reachable"; exit 1; }

# --------------------------
# Prepare configuration early (needed before reliable RPC checks)
# --------------------------
CONF_DIR="$CHAIN_DIR"
CONF_FILE="${CONF_DIR}/multichain.conf"
mkdir -p "$CONF_DIR"
touch "$CONF_FILE"
if ! grep -q '^rpcport=' "$CONF_FILE" 2>/dev/null; then
    echo "rpcport=${RPC_PORT}" >> "$CONF_FILE"
fi
# Inject optional RPC credentials/allow list if provided (matches masternode env)
if [[ -n "${RPC_USER:-}" ]] && ! grep -q '^rpcuser=' "$CONF_FILE" 2>/dev/null; then echo "rpcuser=${RPC_USER}" >> "$CONF_FILE"; fi
if [[ -n "${RPC_PASSWORD:-}" ]] && ! grep -q '^rpcpassword=' "$CONF_FILE" 2>/dev/null; then echo "rpcpassword=${RPC_PASSWORD}" >> "$CONF_FILE"; fi
if [[ -n "${RPC_ALLOWIP:-}" ]] && ! grep -q '^rpcallowip=' "$CONF_FILE" 2>/dev/null; then echo "rpcallowip=${RPC_ALLOWIP}" >> "$CONF_FILE"; fi
GLOBAL_CONF="${HOME_DIR}/.multichain/multichain.conf"
cp "$CONF_FILE" "$GLOBAL_CONF" 2>/dev/null || true

# --------------------------
# Start lightweight local node (daemon) if not already running
# --------------------------
if ! multichain-cli "$CHAIN_NAME" getinfo >/dev/null 2>&1; then
	read -r -a FLAG_ARR <<<"${START_FLAGS}"
	mc_log "[EXPLORER] Starting local multichaind daemon (flags: ${START_FLAGS})"
	multichaind "${CHAIN_NAME}@${ip}:${MASTER_PORT}" -daemon "${FLAG_ARR[@]}" || true

	# Wait for RPC to become ready with progress logging (shorter overall timeout)
	RPC_MAX_ATTEMPTS=$((RETRIES/2))
	rpc_attempt=0
	while [[ $rpc_attempt -lt $RPC_MAX_ATTEMPTS ]]; do
		if multichain-cli "$CHAIN_NAME" getinfo >/dev/null 2>&1; then
			mc_log "[EXPLORER] RPC ready after $((rpc_attempt+1)) attempt(s)"
			break
		fi
		mc_log "[EXPLORER][DEBUG] Waiting for RPC ($((rpc_attempt+1))/$RPC_MAX_ATTEMPTS)"
		sleep "$SLEEP_SECONDS"
		rpc_attempt=$((rpc_attempt+1))
	done
	if ! multichain-cli "$CHAIN_NAME" getinfo >/dev/null 2>&1; then
		mc_log "[EXPLORER][WARN] RPC not confirmed ready after $RPC_MAX_ATTEMPTS attempts; continuing"
	fi
else
	mc_log "[EXPLORER] multichaind already running; skipping start"
fi

# --------------------------
# Generate explorer configuration dynamically (optional)
# --------------------------
EXPLORER_CONF="/home/multichain/explorer.conf"
if [[ "$GENERATE_EXPLORER_CONF" == "1" ]]; then
	cat > "$EXPLORER_CONF" <<EOF
# Autogenerated explorer.conf (CHAIN_NAME=$CHAIN_NAME)
port ${EXPLORER_PORT}
host ${EXPLORER_BIND}
datadir += [{
	"dirname": "/home/multichain/.multichain/${CHAIN_NAME}",
	"loader": "default",
	"chain": "MultiChain ${CHAIN_NAME}",
	"policy": "MultiChain"
}]
dbtype = sqlite3
connect-args = /home/multichain/${CHAIN_NAME}.explorer.sqlite
chainurl = http://localhost:${EXPLORER_PORT}/chain/${CHAIN_NAME}/
EOF
	mc_log "[EXPLORER] Generated explorer configuration at $EXPLORER_CONF"
else
	mc_log "[EXPLORER] Using baked explorer.conf (GENERATE_EXPLORER_CONF=0)"
fi

# --------------------------
# Initial index pass (non-fatal) then serve
# --------------------------
if [[ "$FAST_START" != "1" ]]; then
	mc_log "[EXPLORER][DEBUG] Pre-index pass (FAST_START=0)"
	python -m Mce.abe --config "$EXPLORER_CONF" --commit-bytes "$COMMIT_BYTES" --no-serve || true
else
	mc_log "[EXPLORER][DEBUG] Skipping pre-index (FAST_START=1)"
fi
mc_log "[EXPLORER] Starting explorer web server on ${EXPLORER_BIND}:${EXPLORER_PORT}"
python - <<'EOF'
import sys, pkgutil
print('[EXPLORER][DEBUG] Python version:', sys.version)
print('[EXPLORER][DEBUG] sys.path:')
for p in sys.path:
	print('  -', p)
names = {name for _, name, _ in pkgutil.iter_modules()}
print('[EXPLORER][DEBUG] Mce module present?', 'Mce' in names)

# Apply defensive monkey patches to Mce.abe to avoid NoneType .endswith errors
try:
	import Mce.abe as abe_mod
	import inspect
	src = inspect.getsource(abe_mod)
	patched = []
	for line in src.splitlines():
		if 'tx_hash.endswith' in line:
			line = line.replace('tx_hash.endswith', 'tx_hash and hasattr(tx_hash, "endswith") and tx_hash.endswith')
		if 'assetref.endswith' in line:
			line = line.replace('assetref.endswith', 'assetref and hasattr(assetref, "endswith") and assetref.endswith')
		patched.append(line)
	# Only rewrite if changed
	new_src = '\n'.join(patched)
	if new_src != src:
		import os, tempfile
		path = abe_mod.__file__
		# Write new source (module is already loaded; future reloads will use patched code)
		with open(path, 'w') as f:
			f.write(new_src)
		print('[EXPLORER][DEBUG] Patched abe.py to guard endswith calls')
except Exception as e:
	print('[EXPLORER][WARN] Failed to patch abe.py:', e)
EOF
# Split explorer flags safely
read -r -a EXPLORE_ARR <<<"${EXPLORE_FLAGS}"
# Patch abe.py defensively (idempotent) replacing raw endswith usage with guarded version
ABE_PATH="$(python - <<'PY'
import Mce,inspect,os
import Mce.abe
print(Mce.abe.__file__)
PY
)"
if [[ -f "$ABE_PATH" ]]; then
	sed -i \
		-e "s/tx_hash\.endswith(/tx_hash and hasattr(tx_hash,'endswith') and tx_hash.endswith(/" \
		-e "s/assetref\.endswith(/assetref and hasattr(assetref,'endswith') and assetref.endswith(/" "$ABE_PATH" || true
fi
exec python -m Mce.abe --config "$EXPLORER_CONF" "${EXPLORE_ARR[@]}"